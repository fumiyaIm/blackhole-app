<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ブラックホール観測アプリ</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      color: white;
      background-color: #000;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background-color: #000;
      touch-action: none;
    }
    /* パノラマ星空画像を背景として利用 */
    #skyBackground {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.8;
      z-index: 1;
      /* transform はJSで更新（左右・上下のオフセット） */
    }
    #skyCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
    }
    /* 地平線は画面下部に表示。updateHorizon()で位置を調整 */
    #horizon {
      position: absolute;
      top: 80%;
      left: 0;
      width: 100%;
      height: 20%;
      background: linear-gradient(0deg, rgba(0,20,0,0.8) 0%, rgba(0,0,0,0) 100%);
      z-index: 5;
      pointer-events: none;
    }
    .horizon-label {
      position: absolute;
      bottom: 5px;
      width: 100%;
      text-align: center;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
      pointer-events: none;
    }
    #info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 10px;
      max-width: 80%;
      z-index: 10;
    }
    /* ブラックホール解説用モーダルダイアログ */
    #objectInfo {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 10px;
      max-width: 80%;
      z-index: 200;
      display: none;
    }
    #objectInfo h3 {
      margin-top: 0;
    }
    #objectInfo button {
      background-color: #f44336;
      color: white;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      border-radius: 5px;
      margin-top: 10px;
    }
    #permissionOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 15px 32px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      margin: 20px 2px;
      cursor: pointer;
      border-radius: 10px;
    }
    .blackhole-marker {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.8);
      border: 2px solid rgba(255, 165, 0, 0.8);
      box-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
      transform: translate(-50%, -50%);
      cursor: pointer;
      z-index: 10;
      transition: all 0.3s ease;
    }
    .blackhole-marker:hover {
      transform: translate(-50%, -50%) scale(1.2);
      box-shadow: 0 0 15px rgba(255, 165, 0, 1);
    }
    #loadingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 90;
    }
    .spinner {
      border: 5px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top: 5px solid #ffffff;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    .loading-text {
      color: white;
      font-size: 16px;
      text-align: center;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      display: flex;
      gap: 10px;
    }
    .control-btn {
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }
    .star {
      position: absolute;
      background-color: white;
      border-radius: 50%;
      pointer-events: none;
    }
    #messageBox {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      border: 1px solid #444;
      border-radius: 10px;
      padding: 20px;
      color: white;
      display: none;
      z-index: 200;
      text-align: center;
      max-width: 80%;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- 背景画像はパノラマ星空画像（方向に合わせて移動する） -->
    <img id="skyBackground" src="https://upload.wikimedia.org/wikipedia/commons/e/ed/Milky_Way_Panorama_%28cropped%29.jpg" alt="Starry Sky" />
    <canvas id="skyCanvas"></canvas>
    <div id="horizon">
      <div class="horizon-label">地平線</div>
    </div>
    <div id="controls">
      <button class="control-btn" id="resetViewBtn">視点リセット</button>
      <button class="control-btn" id="toggleSensorsBtn">センサー切替</button>
    </div>
    <div id="info">
      <h3>ブラックホール観測アプリ</h3>
      <p>方向: <span id="direction">北 (0.0°)</span></p>
      <p>緯度経度: <span id="location">35.6895°, 139.6917°</span></p>
      <p>視野内のブラックホール: <span id="visibleCount">0</span></p>
      <p>操作: 画面をドラッグして視点移動</p>
    </div>
    <!-- ブラックホール解説ダイアログ -->
    <div id="objectInfo">
      <h3 id="objectName"></h3>
      <p id="objectDistance"></p>
      <p id="objectMass"></p>
      <p id="objectDescription"></p>
      <button id="closeDialog">閉じる</button>
    </div>
    <div id="permissionOverlay">
      <h2>ブラックホール観測アプリへようこそ</h2>
      <p>このアプリはデバイスの位置情報とジャイロスコープセンサーを使用して、スマートフォンが向いている方向の天球と視野内のブラックホール天体を表示します。</p>
      <p>位置情報やセンサーへのアクセスが許可されない場合でも、デフォルト設定で利用できます。</p>
      <button onclick="startApp()">スタート</button>
    </div>
    <div id="loadingScreen">
      <div class="spinner"></div>
      <div class="loading-text">アプリを読み込み中...</div>
    </div>
    <div id="messageBox"></div>
  </div>

  <script>
    // ヘルパー：値のクランプ
    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    // グローバル変数
    let canvas, ctx;
    let latitude = 35.6895, longitude = 139.6917; // デフォルト：東京
    let alpha = 0, beta = 45, gamma = 0; // センサー値
    let markers = [];
    let stars = [];
    let isRunning = false;
    let useSensors = false; // デフォルトは手動操作
    // マニュアル視点
    let manualAzimuth = 0;
    let manualAltitude = 45;
    let touchStartX = 0, touchStartY = 0;
    let touchLastX = 0, touchLastY = 0;
    let isDragging = false;

    // ※ 背景画像は固定のパノラマ星空画像を利用（changeImage ボタンは省略）

    // ブラックホールデータ
    const blackholes = [
      {
        name: "いて座A*（Sgr A*）",
        ra: 266.4168,
        dec: -29.0078,
        distance: "2.6万光年",
        mass: "約400万太陽質量",
        description: "天の川銀河の中心に位置する超大質量ブラックホール。2022年に初めて直接撮影されました。"
      },
      {
        name: "M87銀河中心ブラックホール",
        ra: 187.7059,
        dec: 12.3911,
        distance: "5,500万光年",
        mass: "約65億太陽質量",
        description: "おとめ座銀河団のM87銀河の中心に位置する超大質量ブラックホール。2019年にイベント・ホライズン・テレスコープにより初撮影。"
      },
      {
        name: "シグナス X-1",
        ra: 299.5903,
        dec: 35.2016,
        distance: "約6,000光年",
        mass: "約15太陽質量",
        description: "はくちょう座に位置する恒星質量ブラックホール。X線連星系で伴星から物質を降着。"
      },
      {
        name: "GW150914",
        ra: 129.1,
        dec: -70.3,
        distance: "約13億光年",
        mass: "合体前: 36太陽質量と29太陽質量、合体後: 62太陽質量",
        description: "2015年に重力波で初検出されたブラックホール連星合体イベント。"
      },
      {
        name: "Swift J1644+57",
        ra: 251.2059,
        dec: 57.5853,
        distance: "約38億光年",
        mass: "推定数百万太陽質量",
        description: "潮汐破壊現象が観測された超大質量ブラックホール。星が近づきすぎて破壊されるイベントが観測。"
      }
    ];

    // アプリ開始
    function startApp() {
      document.getElementById('permissionOverlay').style.display = 'none';
      document.getElementById('loadingScreen').style.display = 'flex';

      try {
        canvas = document.getElementById('skyCanvas');
        ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // 位置情報取得
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            function(position) {
              latitude = position.coords.latitude;
              longitude = position.coords.longitude;
              document.getElementById('location').textContent = `${latitude.toFixed(4)}°, ${longitude.toFixed(4)}°`;
              updateBlackholeMarkers();
            },
            function(error) {
              console.warn('位置情報エラー:', error);
              showMessage("位置情報が取得できませんでした。デフォルト位置（東京）を使用します。", 3000);
            },
            { enableHighAccuracy: false, timeout: 5000, maximumAge: 60000 }
          );
        }

        // センサー設定
        if (window.DeviceOrientationEvent) {
          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
              .then(function(permission) {
                if (permission === 'granted') {
                  window.addEventListener('deviceorientation', handleOrientation);
                  useSensors = true;
                  document.getElementById('toggleSensorsBtn').textContent = 'センサーOFF';
                } else {
                  useFallbackOrientation();
                }
              })
              .catch(function(error) {
                useFallbackOrientation();
                showMessage("センサーが利用できないため、手動操作モードになります。", 3000);
              });
          } else {
            window.addEventListener('deviceorientation', handleOrientation);
            useSensors = true;
            document.getElementById('toggleSensorsBtn').textContent = 'センサーOFF';
          }
        } else {
          useFallbackOrientation();
          showMessage("このデバイスはセンサーをサポートしていません。手動操作モードになります。", 3000);
        }

        generateStars();
        setupTouchControls();

        document.getElementById('resetViewBtn').addEventListener('click', resetView);
        document.getElementById('toggleSensorsBtn').addEventListener('click', toggleSensors);
        document.getElementById('closeDialog').addEventListener('click', function() {
          document.getElementById('objectInfo').style.display = 'none';
        });

        window.addEventListener('resize', handleResize);

        document.getElementById('loadingScreen').style.display = 'none';
        isRunning = true;

        // requestAnimationFrame による連続更新
        updateSky();
      } catch (error) {
        console.error('アプリ開始エラー:', error);
        document.getElementById('loadingScreen').style.display = 'none';
        showMessage("エラーが発生しましたが、基本機能は利用できます: " + error.message, 5000);
        useFallbackOrientation();
        isRunning = true;
        createBlackholeMarkers();
      }
    }

    // メッセージ表示
    function showMessage(message, duration) {
      const messageBox = document.getElementById('messageBox');
      messageBox.textContent = message;
      messageBox.style.display = 'block';
      setTimeout(() => { messageBox.style.display = 'none'; }, duration);
    }

    // ブラックホールマーカー簡易生成
    function createBlackholeMarkers() {
      blackholes.forEach((blackhole, index) => {
        const x = window.innerWidth / 2 + (index - 2) * 60;
        const y = window.innerHeight / 2;
        createBlackholeMarker(blackhole, x, y, true);
      });
      document.getElementById('visibleCount').textContent = blackholes.length;
    }

    // 星生成
    function generateStars() {
      stars.forEach(star => {
        if (star.element && star.element.parentNode) {
          star.element.parentNode.removeChild(star.element);
        }
      });
      stars = [];
      const container = document.getElementById('container');
      const width = window.innerWidth;
      const height = window.innerHeight;
      for (let i = 0; i < 100; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        const size = Math.random() * 2 + 1;
        const opacity = Math.random() * 0.5 + 0.5;
        star.style.width = size + 'px';
        star.style.height = size + 'px';
        star.style.left = Math.random() * width + 'px';
        star.style.top = Math.random() * height + 'px';
        star.style.opacity = opacity;
        container.appendChild(star);
        stars.push({ element: star, x: parseFloat(star.style.left), y: parseFloat(star.style.top) });
      }
    }

    // リサイズ処理
    function handleResize() {
      if (canvas) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      generateStars();
      if (isRunning) {
        updateBlackholeMarkers();
      }
    }

    // 背景画像移動：センサー（または手動）の水平・垂直の値に応じて translateX/Y を設定  
    function updateBackgroundPosition() {
      // 水平方向は α（または manualAzimuth）から ±最大50%オフセット
      let currentAzimuth = useSensors ? alpha : manualAzimuth;
      let normalizedAzimuth = ((currentAzimuth + 180) % 360) - 180;
      const maxOffsetX = window.innerWidth * 0.5;
      let offsetX = (normalizedAzimuth / 180) * maxOffsetX;
      // 垂直方向は、センサーの場合は beta の半分を 45°中心に（0～90°にクランプ）、手動の場合は manualAltitude を使用  
      let currentAltitude = useSensors ? clamp(45 + beta / 2, 0, 90) : manualAltitude;
      const maxOffsetY = window.innerHeight * 0.3;
      let offsetY = ((currentAltitude - 45) / 45) * maxOffsetY;
      document.getElementById('skyBackground').style.transform = `translate(${offsetX}px, ${offsetY}px)`;
    }

    // 地平線位置更新（デバイスの傾きに合わせ上下移動）
    function updateHorizon() {
      let currentAltitude = useSensors ? clamp(45 + beta / 2, 0, 90) : manualAltitude;
      let horizonY = window.innerHeight - (currentAltitude / 90) * (window.innerHeight * 0.5);
      document.getElementById('horizon').style.top = `${horizonY}px`;
    }

    // 天球全体の更新（連続更新）
    function updateSky() {
      if (!isRunning) return;
      updateBackgroundPosition();
      updateHorizon();
      updateBlackholeMarkers();
      requestAnimationFrame(updateSky);
    }

    // センサー未対応時の固定方向設定
    function useFallbackOrientation() {
      useSensors = false;
      document.getElementById('toggleSensorsBtn').textContent = 'センサーON';
      alpha = 0;
      beta = 45;
      manualAzimuth = 0;
      manualAltitude = 45;
      updateDirectionText(0);
    }

    // 方角テキスト更新
    function updateDirectionText(heading) {
      const directions = ["北", "北東", "東", "南東", "南", "南西", "西", "北西"];
      const index = Math.round(heading / 45) % 8;
      document.getElementById('direction').textContent = `${directions[index]} (${heading.toFixed(1)}°)`;
    }

    // センサーによる向き更新（α, β, γ の値を取得し、手動視点に反映）
    function handleOrientation(event) {
      if (!useSensors) return;
      try {
        alpha = event.alpha || 0;
        beta = event.beta || 0;
        gamma = event.gamma || 0;
        let heading = 360 - alpha;
        if (heading < 0) heading += 360;
        if (heading > 360) heading -= 360;
        manualAzimuth = heading;
        // beta の値を利用して上下方向：45 + (beta/2) を 0～90°にクランプ
        manualAltitude = clamp(45 + beta / 2, 0, 90);
        updateDirectionText(heading);
      } catch (error) {
        console.warn('向き検出エラー:', error);
        useSensors = false;
        document.getElementById('toggleSensorsBtn').textContent = 'センサーON';
      }
    }

    // タッチ／マウス操作セットアップ
    function setupTouchControls() {
      const container = document.getElementById('container');
      container.addEventListener('touchstart', handleTouchStart, false);
      container.addEventListener('touchmove', handleTouchMove, false);
      container.addEventListener('touchend', handleTouchEnd, false);
      container.addEventListener('mousedown', handleMouseDown, false);
      container.addEventListener('mousemove', handleMouseMove, false);
      container.addEventListener('mouseup', handleMouseUp, false);
    }

    function handleTouchStart(event) {
      event.preventDefault();
      const touch = event.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchLastX = touchStartX;
      touchLastY = touchStartY;
      isDragging = true;
      if (isDragging) {
        useSensors = false;
        document.getElementById('toggleSensorsBtn').textContent = 'センサーON';
      }
    }

    function handleTouchMove(event) {
      if (!isDragging) return;
      event.preventDefault();
      const touch = event.touches[0];
      const deltaX = touch.clientX - touchLastX;
      const deltaY = touch.clientY - touchLastY;
      manualAzimuth = (manualAzimuth - deltaX * 0.5) % 360;
      if (manualAzimuth < 0) manualAzimuth += 360;
      manualAltitude += deltaY * 0.5;
      manualAltitude = clamp(manualAltitude, 0, 90);
      touchLastX = touch.clientX;
      touchLastY = touch.clientY;
      updateDirectionText(manualAzimuth);
      updateBlackholeMarkers();
    }

    function handleTouchEnd(event) {
      isDragging = false;
    }

    function handleMouseDown(event) {
      event.preventDefault();
      touchStartX = event.clientX;
      touchStartY = event.clientY;
      touchLastX = touchStartX;
      touchLastY = touchStartY;
      isDragging = true;
      if (isDragging) {
        useSensors = false;
        document.getElementById('toggleSensorsBtn').textContent = 'センサーON';
      }
    }

    function handleMouseMove(event) {
      if (!isDragging) return;
      event.preventDefault();
      const deltaX = event.clientX - touchLastX;
      const deltaY = event.clientY - touchLastY;
      manualAzimuth = (manualAzimuth - deltaX * 0.5) % 360;
      if (manualAzimuth < 0) manualAzimuth += 360;
      manualAltitude += deltaY * 0.5;
      manualAltitude = clamp(manualAltitude, 0, 90);
      touchLastX = event.clientX;
      touchLastY = event.clientY;
      updateDirectionText(manualAzimuth);
      updateBlackholeMarkers();
    }

    function handleMouseUp(event) {
      isDragging = false;
    }

    // 視点リセット：手動視点をリセットし、センサー連動に戻す
    function resetView() {
      manualAzimuth = 0;
      manualAltitude = 45;
      updateDirectionText(manualAzimuth);
      useSensors = true;
      document.getElementById('toggleSensorsBtn').textContent = 'センサーOFF';
      updateBlackholeMarkers();
      updateBackgroundPosition();
      updateHorizon();
      showMessage("視点をリセットしました", 1000);
    }

    // センサー切替
    function toggleSensors() {
      useSensors = !useSensors;
      if (useSensors) {
        document.getElementById('toggleSensorsBtn').textContent = 'センサーOFF';
        showMessage("センサーモードに切り替えました", 1000);
      } else {
        document.getElementById('toggleSensorsBtn').textContent = 'センサーON';
        showMessage("手動操作モードに切り替えました", 1000);
      }
      updateBlackholeMarkers();
    }

    // ブラックホールマーカー更新
    function updateBlackholeMarkers() {
      try {
        markers.forEach(marker => {
          if (marker.element && marker.element.parentNode) {
            marker.element.parentNode.removeChild(marker.element);
          }
        });
        markers = [];
        const now = new Date();
        let visibleCount = 0;
        blackholes.forEach(blackhole => {
          try {
            const horizontal = equatorialToHorizontal(blackhole.ra, blackhole.dec, latitude, longitude, now);
            const isAboveHorizon = horizontal.altitude >= 0;
            const screenPos = calculateScreenPosition(horizontal.azimuth, horizontal.altitude);
            if (screenPos.isVisible && (isAboveHorizon || horizontal.altitude > -10)) {
              createBlackholeMarker(blackhole, screenPos.x, screenPos.y, isAboveHorizon, horizontal.altitude);
              if (isAboveHorizon) visibleCount++;
            }
          } catch (error) {
            console.warn(`ブラックホール「${blackhole.name}」処理エラー:`, error);
          }
        });
        document.getElementById('visibleCount').textContent = visibleCount;
      } catch (error) {
        console.error('マーカー更新エラー:', error);
        createBlackholeMarkers();
      }
    }

    // ブラックホールマーカー作成
    function createBlackholeMarker(blackhole, x, y, isAboveHorizon, altitude) {
      const marker = document.createElement('div');
      marker.className = 'blackhole-marker';
      marker.style.left = `${x}px`;
      marker.style.top = `${y}px`;
      if (!isAboveHorizon) {
        const opacity = (altitude + 10) / 10 * 0.5;
        marker.style.opacity = opacity;
        marker.style.border = '1px solid rgba(255, 0, 0, 0.8)';
        marker.style.backgroundColor = 'rgba(100, 0, 0, 0.5)';
      }
      marker.addEventListener('click', function() {
        showBlackholeInfo(blackhole, isAboveHorizon);
      });
      document.getElementById('container').appendChild(marker);
      markers.push({ element: marker, blackhole: blackhole, isAboveHorizon: isAboveHorizon });
    }

    // ブラックホール情報ダイアログ表示
    function showBlackholeInfo(blackhole, isAboveHorizon) {
      const infoDialog = document.getElementById('objectInfo');
      document.getElementById('objectName').textContent = blackhole.name;
      document.getElementById('objectDistance').textContent = `距離: ${blackhole.distance}`;
      document.getElementById('objectMass').textContent = `質量: ${blackhole.mass}`;
      let description = blackhole.description;
      if (!isAboveHorizon) {
        description += "\n（注意：この天体は現在地平線より下にあります）";
      }
      document.getElementById('objectDescription').textContent = description;
      infoDialog.style.display = 'block';
    }

    // ユリウス日計算
    function getJulianDate(date) {
      const time = date.getTime();
      return (time / 86400000) + 2440587.5;
    }

    // ローカル恒星時計算
    function getLocalSiderealTime(jd, longitude) {
      try {
        const T = (jd - 2451545.0) / 36525;
        let theta = 280.46061837 + 360.98564736629 * (jd - 2451545.0) +
                    0.000387933 * T * T - T * T * T / 38710000;
        theta += longitude;
        theta = theta % 360;
        if (theta < 0) theta += 360;
        return theta;
      } catch (error) {
        const now = new Date();
        const hours = now.getUTCHours();
        const minutes = now.getUTCMinutes();
        return (hours + minutes / 60) * 15 + longitude;
      }
    }

    // 赤経・赤緯 → 地平座標変換
    function equatorialToHorizontal(ra, dec, lat, lon, date) {
      try {
        const jd = getJulianDate(date);
        const lst = getLocalSiderealTime(jd, lon);
        const ha = lst - ra;
        const decRad = dec * Math.PI / 180;
        const latRad = lat * Math.PI / 180;
        const haRad = ha * 15 * Math.PI / 180;
        const sinAlt = Math.sin(decRad) * Math.sin(latRad) +
                       Math.cos(decRad) * Math.cos(latRad) * Math.cos(haRad);
        const alt = Math.asin(sinAlt) * 180 / Math.PI;
        const cosA = (Math.sin(decRad) - Math.sin(latRad) * sinAlt) /
                     (Math.cos(latRad) * Math.cos(Math.asin(sinAlt)));
        let az = Math.acos(Math.max(-1, Math.min(1, cosA))) * 180 / Math.PI;
        if (Math.sin(haRad) > 0) {
          az = 360 - az;
        }
        return { azimuth: az, altitude: alt };
      } catch (error) {
        console.warn('座標変換エラー:', error);
        return { azimuth: 0, altitude: 45 };
      }
    }

    // スクリーン座標計算
    function calculateScreenPosition(azimuth, altitude) {
      try {
        const fovHorizontal = 60;
        const fovVertical = fovHorizontal * (canvas.height / canvas.width);
        let centerAzimuth, centerAltitude;
        if (useSensors) {
          centerAzimuth = manualAzimuth;
          centerAltitude = clamp(45 + beta / 2, 0, 90);
        } else {
          centerAzimuth = manualAzimuth;
          centerAltitude = manualAltitude;
        }
        let deltaAz = azimuth - centerAzimuth;
        if (deltaAz > 180) deltaAz -= 360;
        if (deltaAz < -180) deltaAz += 360;
        const deltaAlt = altitude - centerAltitude;
        const xRatio = deltaAz / (fovHorizontal / 2);
        const yRatio = -deltaAlt / (fovVertical / 2);
        const x = (xRatio * 0.5 + 0.5) * canvas.width;
        const y = (yRatio * 0.5 + 0.5) * canvas.height;
        const isVisible = Math.abs(xRatio) <= 1 && Math.abs(yRatio) <= 1;
        return { x, y, isVisible };
      } catch (error) {
        console.warn('スクリーン位置計算エラー:', error);
        return { x: canvas.width / 2, y: canvas.height / 2, isVisible: true };
      }
    }
  </script>
</body>
</html>
