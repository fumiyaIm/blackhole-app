<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ブラックホール観測アプリ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            color: white;
            background-color: #000;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            overflow: hidden;
        }
        #skyCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        #starField {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transform-style: preserve-3d;
            perspective: 1000px;
        }
        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: white;
            border-radius: 50%;
            transform-style: preserve-3d;
            will-change: transform;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            max-width: 80%;
            z-index: 10;
        }
        #objectInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            max-width: 80%;
            display: none;
            z-index: 10;
        }
        #permissionOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 20px 2px;
            cursor: pointer;
            border-radius: 10px;
        }
        .blackhole-marker {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 165, 0, 0.8);
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.8);
            transform: translate(-50%, -50%);
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
        }
        #horizon {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 20%;
            background: linear-gradient(0deg, rgba(0,40,0,0.8) 0%, rgba(0,0,0,0) 100%);
            z-index: 5;
            pointer-events: none;
            transition: all 0.5s ease;
        }
        .horizon-label {
            position: absolute;
            bottom: 5px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            gap: 10px;
        }
        .control-btn {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        #orientationInfo {
            position: absolute;
            top: 60px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #aaa;
            z-index: 10;
        }
        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 10px;
            padding: 20px;
            color: white;
            display: none;
            z-index: 200;
            text-align: center;
            max-width: 80%;
        }
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 90;
        }
        .spinner {
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 5px solid #ffffff;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        .loading-text {
            color: white;
            font-size: 16px;
            text-align: center;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .constellation {
            position: absolute;
            color: rgba(100, 150, 255, 0.6);
            font-size: 14px;
            pointer-events: none;
            z-index: 3;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            transform-style: preserve-3d;
            will-change: transform;
        }
        /* 天球グリッド用のスタイル */
        .grid-line {
            position: absolute;
            background-color: rgba(100, 100, 255, 0.3);
            pointer-events: none;
            transform-style: preserve-3d;
            will-change: transform;
            z-index: 2;
        }
        .grid-line-ra {
            border-top: 1px dashed rgba(100, 150, 255, 0.4);
        }
        .grid-line-dec {
            border-left: 1px dashed rgba(150, 100, 255, 0.4);
        }
        .grid-label {
            position: absolute;
            color: rgba(150, 200, 255, 0.7);
            font-size: 10px;
            pointer-events: none;
            z-index: 3;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.9);
            transform-style: preserve-3d;
            will-change: transform;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="starField"></div>
        <canvas id="skyCanvas"></canvas>
        <div id="horizon">
            <div class="horizon-label">地平線</div>
        </div>
        <div id="controls">
            <button class="control-btn" id="resetViewBtn">視点リセット</button>
            <button class="control-btn" id="toggleSensorsBtn">センサー切替</button>
        </div>
        <div id="orientationInfo">
            <p>α: <span id="alphaValue">0</span>°, β: <span id="betaValue">0</span>°, γ: <span id="gammaValue">0</span>°</p>
            <p>視点: <span id="viewDirection">北 (0.0°)</span></p>
        </div>
        <div id="info">
            <h3>ブラックホール観測アプリ</h3>
            <p>緯度経度: <span id="location">35.6895°, 139.6917°</span></p>
            <p>視野内のブラックホール: <span id="visibleCount">0</span></p>
            <p>操作: 画面をドラッグして視点移動</p>
        </div>
        <div id="objectInfo">
            <h3 id="objectName"></h3>
            <p id="objectDistance"></p>
            <p id="objectMass"></p>
            <p id="objectDescription"></p>
        </div>
        <div id="permissionOverlay">
            <h2>ブラックホール観測アプリへようこそ</h2>
            <p>このアプリはデバイスの位置情報とジャイロスコープセンサーを使用して、スマートフォンが向いている方向の天球と視野内のブラックホール天体を表示します。</p>
            <p>位置情報やセンサーへのアクセスが許可されない場合でも、デフォルト設定で利用できます。</p>
            <!-- 直接 JS関数を呼び出すインラインイベントハンドラ -->
            <button id="startBtn" onclick="hideOverlay()">スタート</button>
            <!-- 緊急用バックアップボタン -->
            <a href="#" style="margin-top:20px;color:#AAA;font-size:12px;" onclick="forceStart();return false;">問題が発生する場合はこちらをクリック</a>
        </div>
        <div id="loadingScreen">
            <div class="spinner"></div>
            <div class="loading-text">星空データを読み込み中...</div>
        </div>
        <div id="messageBox"></div>
    </div>

    <script>
        // グローバル変数
        let canvas, ctx;
        let latitude = 35.6895, longitude = 139.6917; // デフォルト位置（東京）
        let alpha = 0, beta = 0, gamma = 0; // デバイスの向き
        let markers = [];
        let stars = [];
        let constellations = [];
        let isRunning = false;
        let useSensors = true; // センサー使用フラグ
        let orientationLocked = false; // 方向ロックフラグ
        
        // 星空の3D表現用の変数
        const starCount = 1000; // 生成する星の数
        const starFieldRadius = 5000; // 星空の半径（px）
        
        // マニュアル視点制御用変数
        let manualAzimuth = 0;   // 手動方位角
        let manualAltitude = 45; // 手動高度
        let touchStartX = 0;
        let touchStartY = 0;
        let touchLastX = 0;
        let touchLastY = 0;
        let isDragging = false;
        
        // 地平線の現在の位置
        let horizonPosition = 'bottom'; // 'bottom', 'top', 'left', 'right'
        
        // 天球グリッド用の変数
        let gridLines = [];
        let showGrid = true; // デフォルトでグリッド表示
        
        // 星座データ（主要な星座の代表的な位置と名前）
        const constellationData = [
            { name: "オリオン座", ra: 5.5, dec: 5 },
            { name: "しし座", ra: 10.5, dec: 15 },
            { name: "おおぐま座", ra: 10.5, dec: 50 },
            { name: "こぐま座", ra: 15, dec: 80 },
            { name: "りゅう座", ra: 17, dec: 60 },
            { name: "はくちょう座", ra: 20.5, dec: 40 },
            { name: "カシオペア座", ra: 1, dec: 60 },
            { name: "ペガスス座", ra: 23, dec: 20 },
            { name: "アンドロメダ座", ra: 1, dec: 40 },
            { name: "ケフェウス座", ra: 22, dec: 70 },
            { name: "うお座", ra: 1, dec: 10 },
            { name: "みずがめ座", ra: 22.5, dec: -10 },
            { name: "やぎ座", ra: 21, dec: -20 },
            { name: "いて座", ra: 19, dec: -25 },
            { name: "さそり座", ra: 17, dec: -30 },
            { name: "てんびん座", ra: 15.5, dec: -15 },
            { name: "おとめ座", ra: 13.5, dec: 0 },
            { name: "うみへび座", ra: 10.5, dec: -15 },
            { name: "かに座", ra: 8.5, dec: 20 },
            { name: "ふたご座", ra: 7, dec: 20 },
            { name: "おうし座", ra: 5, dec: 17 },
            { name: "ペルセウス座", ra: 3.5, dec: 40 }
        ];

        // ブラックホールのデータベース
        const blackholes = [
            {
                name: "いて座A*（Sgr A*）",
                ra: 266.4168, // 赤経 (度)
                dec: -29.0078, // 赤緯 (度)
                distance: "2.6万光年",
                mass: "約400万太陽質量",
                description: "天の川銀河の中心に位置する超大質量ブラックホール。2022年に初めて直接撮影されました。"
            },
            {
                name: "M87銀河中心ブラックホール",
                ra: 187.7059,
                dec: 12.3911,
                distance: "5,500万光年",
                mass: "約65億太陽質量",
                description: "おとめ座銀河団のM87銀河の中心に位置する超大質量ブラックホール。2019年にイベント・ホライズン・テレスコープによって史上初めて撮影されました。"
            },
            {
                name: "シグナス X-1",
                ra: 299.5903,
                dec: 35.2016,
                distance: "約6,000光年",
                mass: "約15太陽質量",
                description: "はくちょう座に位置する恒星質量ブラックホール。X線連星系で、伴星からの物質を降着しています。"
            },
            {
                name: "GW150914",
                ra: 129.1,
                dec: -70.3,
                distance: "約13億光年",
                mass: "合体前: 36太陽質量と29太陽質量、合体後: 62太陽質量",
                description: "2015年に重力波で初めて検出されたブラックホール連星の合体イベント。"
            },
            {
                name: "Swift J1644+57",
                ra: 251.2059,
                dec: 57.5853,
                distance: "約38億光年",
                mass: "推定数百万太陽質量",
                description: "潮汐破壊現象が観測された超大質量ブラックホール。星が近づきすぎて破壊されるイベントが観測されました。"
            }
        ];

        // ★★ 最も重要な関数: オーバーレイを非表示にする ★★
        function hideOverlay() {
            console.log("hideOverlay関数が呼び出されました");
            // ロード画面を表示
            document.getElementById('loadingScreen').style.display = 'flex';
            // 直接スタイルで非表示に
            document.getElementById('permissionOverlay').style.display = 'none';
            // アプリを初期化
            setTimeout(function() {
                initializeApp();
            }, 500);
        }

        // ★★ 緊急用の強制スタート関数 ★★
        function forceStart() {
            console.log("forceStart関数が呼び出されました");
            // 直接非表示に
            document.getElementById('permissionOverlay').style.display = 'none';
            // 最小限の機能だけ初期化
            createSimpleBlackholeMarkers();
            isRunning = true;
            showMessage('緊急モードで起動しました。機能は制限されています。', 3000);
        }

        // メッセージを表示
        function showMessage(message, duration) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            
            setTimeout(function() {
                messageBox.style.display = 'none';
            }, duration);
        }

        // アプリの初期化処理
        function initializeApp() {
            console.log("initializeApp関数が呼び出されました");
            
            try {
                // キャンバスの初期化
                canvas = document.getElementById('skyCanvas');
                ctx = canvas.getContext('2d');
                
                // キャンバスサイズをウィンドウに合わせる
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // 3D星空を生成
                generate3DStarField();
                
                // 星座を生成
                generateConstellations();
                
                // 位置情報取得
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        function(position) {
                            latitude = position.coords.latitude;
                            longitude = position.coords.longitude;
                            const locationElement = document.getElementById('location');
                            if (locationElement) {
                                locationElement.textContent = `${latitude.toFixed(4)}°, ${longitude.toFixed(4)}°`;
                            }
                            updateBlackholeMarkers();
                        },
                        function(error) {
                            // エラーは無視してデフォルト値を使用
                            console.warn('位置情報エラー:', error);
                            showMessage("位置情報が取得できませんでした。デフォルト位置（東京）を使用します。", 3000);
                        },
                        {
                            enableHighAccuracy: false,
                            timeout: 5000,
                            maximumAge: 60000
                        }
                    );
                }
                
                // デバイスの向きセンサー設定
                if (window.DeviceOrientationEvent) {
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        // iOS
                        DeviceOrientationEvent.requestPermission()
                            .then(function(permission) {
                                if (permission === 'granted') {
                                    window.addEventListener('deviceorientation', handleOrientation);
                                    useSensors = true;
                                    document.getElementById('toggleSensorsBtn').textContent = 'センサーOFF';
                                } else {
                                    useFallbackOrientation();
                                }
                            })
                            .catch(function(error) {
                                useFallbackOrientation();
                                showMessage("センサーが利用できないため、手動操作モードになります。", 3000);
                            });
                    } else {
                        // Android など
                        window.addEventListener('deviceorientation', handleOrientation);
                        useSensors = true;
                        document.getElementById('toggleSensorsBtn').textContent = 'センサーOFF';
                    }
                } else {
                    useFallbackOrientation();
                    showMessage("このデバイスはセンサーをサポートしていません。手動操作モードになります。", 3000);
                }
                
                // コントロールボタンのイベント設定
                document.getElementById('resetViewBtn').addEventListener('click', resetView);
                document.getElementById('toggleSensorsBtn').addEventListener('click', toggleSensors);
                
                // タッチ/マウスイベントの設定
                setupTouchControls();
                
                // リサイズイベントの設定
                window.addEventListener('resize', handleResize);
                
                // ブラックホールマーカーを表示
                createBlackholeMarkers();
                
                // 画面の向き変更イベントの設定
                window.addEventListener('orientationchange', handleOrientationChange);
                
                // コントロールにグリッド切替ボタンを追加
                const controlsDiv = document.getElementById('controls');
                const gridBtn = document.createElement('button');
                gridBtn.className = 'control-btn';
                gridBtn.id = 'toggleGridBtn';
                gridBtn.textContent = 'グリッドOFF';
                gridBtn.addEventListener('click', toggleGrid);
                controlsDiv.appendChild(gridBtn);
                
                // 天球グリッドを生成
                generateCelestialGrid();
                
                // ロード画面を非表示
                document.getElementById('loadingScreen').style.display = 'none';
                
                // 実行フラグを有効に
                isRunning = true;
                
                // 定期的に視点を更新
                setInterval(updateView, 30); // 約33fpsで更新
                
            } catch (error) {
                console.error('初期化エラー:', error);
                // エラーでも最低限の表示はする
                document.getElementById('loadingScreen').style.display = 'none';
                createSimpleBlackholeMarkers();
                isRunning = true;
                showMessage('エラーが発生しましたが、基本機能は動作しています: ' + error.message, 5000);
            }
        }
        
        // 3D星空を生成
        function generate3DStarField() {
            const starField = document.getElementById('starField');
            starField.innerHTML = ''; // 既存の星をクリア
            stars = [];
            
            // 星の位置をランダムに生成（球面上にランダム分布）
            for (let i = 0; i < starCount; i++) {
                // 球面上の均一な乱数分布を生成
                const theta = Math.random() * Math.PI * 2; // 0-2πの方位角
                const phi = Math.acos(2 * Math.random() - 1); // 0-πの天頂角
                
                // 球面座標を直交座標に変換
                const x = starFieldRadius * Math.sin(phi) * Math.cos(theta);
                const y = starFieldRadius * Math.sin(phi) * Math.sin(theta);
                const z = starFieldRadius * Math.cos(phi);
                
                // 星の明るさと大きさをランダムに決定
                const brightness = Math.random();
                const size = brightness * 2 + 1; // 明るい星ほど大きく
                
                // 星の要素を作成
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                star.style.opacity = brightness * 0.7 + 0.3; // 明るさを透明度に反映
                
                // スクリーン座標を仮設定（実際の位置は更新時に計算）
                star.style.left = '50%';
                star.style.top = '50%';
                
                // 星空コンテナに追加
                starField.appendChild(star);
                
                // 星のデータを記録
                stars.push({
                    element: star,
                    x: x,
                    y: y,
                    z: z,
                    size: size,
                    brightness: brightness
                });
            }
            
            console.log(`3D星空を生成しました: ${stars.length}個の星`);
        }
        
        // 星座を生成
        function generateConstellations() {
            const starField = document.getElementById('starField');
            
            // 既存の星座をクリア
            constellations.forEach(constellation => {
                if (constellation.element && constellation.element.parentNode) {
                    constellation.element.parentNode.removeChild(constellation.element);
                }
            });
            constellations = [];
            
            // 星座データから3D位置に変換
            constellationData.forEach(constellation => {
                // 赤経・赤緯から3D座標に変換
                const ra = constellation.ra * 15; // 時間から度に変換
                const dec = constellation.dec;
                
                // 赤経・赤緯を直交座標に変換
                const phi = (90 - dec) * Math.PI / 180; // 天頂角（北極が0）
                const theta = ra * Math.PI / 180; // 方位角
                
                const x = starFieldRadius * Math.sin(phi) * Math.cos(theta);
                const y = starFieldRadius * Math.sin(phi) * Math.sin(theta);
                const z = starFieldRadius * Math.cos(phi);
                
                // 星座名の要素を作成
                const element = document.createElement('div');
                element.className = 'constellation';
                element.textContent = constellation.name;
                element.style.left = '50%';
                element.style.top = '50%';
                
                // 星空コンテナに追加
                starField.appendChild(element);
                
                // 星座データを記録
                constellations.push({
                    element: element,
                    name: constellation.name,
                    x: x,
                    y: y,
                    z: z,
                    ra: ra,
                    dec: dec
                });
            });
            
            console.log(`星座データを生成しました: ${constellations.length}個の星座`);
        }
        
        // 天球グリッドを生成する関数
        function generateCelestialGrid() {
            const starField = document.getElementById('starField');
            
            // 既存のグリッドをクリア
            gridLines.forEach(line => {
                if (line.element && line.element.parentNode) {
                    line.element.parentNode.removeChild(line.element);
                }
            });
            gridLines = [];
            
            // グリッドを非表示設定の場合は、ここで終了
            if (!showGrid) return;
            
            // 赤経線（経度線に相当）- 15度ごとに作成（1時間ごと）
            for (let ra = 0; ra < 360; ra += 15) {
                // 赤経線の点を計算
                const points = [];
                for (let dec = -80; dec <= 80; dec += 5) {
                    // 赤経・赤緯を直交座標に変換
                    const phi = (90 - dec) * Math.PI / 180; // 天頂角（北極が0）
                    const theta = ra * Math.PI / 180; // 方位角
                    
                    const x = starFieldRadius * Math.sin(phi) * Math.cos(theta);
                    const y = starFieldRadius * Math.sin(phi) * Math.sin(theta);
                    const z = starFieldRadius * Math.cos(phi);
                    
                    points.push({ x, y, z });
                }
                
                // 線分を作成
                for (let i = 0; i < points.length - 1; i++) {
                    const lineElement = document.createElement('div');
                    lineElement.className = 'grid-line grid-line-ra';
                    lineElement.style.left = '50%';
                    lineElement.style.top = '50%';
                    
                    // 線の長さと角度は動的に計算される
                    starField.appendChild(lineElement);
                    
                    // グリッドデータを記録
                    gridLines.push({
                        element: lineElement,
                        startPoint: points[i],
                        endPoint: points[i + 1],
                        type: 'ra'
                    });
                }
                
                // 赤経ラベルを追加（北と南に）
                if (ra % 30 === 0) { // 2時間ごとにラベル表示
                    const hours = ra / 15;
                    
                    // 北側ラベル（赤緯+45度位置）
                    const northLabelElement = document.createElement('div');
                    northLabelElement.className = 'grid-label';
                    northLabelElement.textContent = `${hours}h`;
                    
                    const northPhi = (90 - 45) * Math.PI / 180;
                    const northTheta = ra * Math.PI / 180;
                    
                    const northX = starFieldRadius * Math.sin(northPhi) * Math.cos(northTheta);
                    const northY = starFieldRadius * Math.sin(northPhi) * Math.sin(northTheta);
                    const northZ = starFieldRadius * Math.cos(northPhi);
                    
                    starField.appendChild(northLabelElement);
                    
                    gridLines.push({
                        element: northLabelElement,
                        x: northX,
                        y: northY,
                        z: northZ,
                        type: 'label'
                    });
                    
                    // 南側ラベル（赤緯-45度位置）
                    const southLabelElement = document.createElement('div');
                    southLabelElement.className = 'grid-label';
                    southLabelElement.textContent = `${hours}h`;
                    
                    const southPhi = (90 - (-45)) * Math.PI / 180;
                    const southTheta = ra * Math.PI / 180;
                    
                    const southX = starFieldRadius * Math.sin(southPhi) * Math.cos(southTheta);
                    const southY = starFieldRadius * Math.sin(southPhi) * Math.sin(southTheta);
                    const southZ = starFieldRadius * Math.cos(southPhi);
                    
                    starField.appendChild(southLabelElement);
                    
                    gridLines.push({
                        element: southLabelElement,
                        x: southX,
                        y: southY,
                        z: southZ,
                        type: 'label'
                    });
                }
            }
            
            // 赤緯線（緯度線に相当）- 15度ごとに作成
            for (let dec = -75; dec <= 75; dec += 15) {
                if (dec === 0) continue; // 天の赤道は特別に処理する
                
                const points = [];
                // 赤経を15度ごとにサンプリング
                for (let ra = 0; ra <= 360; ra += 15) {
                    // 赤経・赤緯を直交座標に変換
                    const phi = (90 - dec) * Math.PI / 180; // 天頂角（北極が0）
                    const theta = ra * Math.PI / 180; // 方位角
                    
                    const x = starFieldRadius * Math.sin(phi) * Math.cos(theta);
                    const y = starFieldRadius * Math.sin(phi) * Math.sin(theta);
                    const z = starFieldRadius * Math.cos(phi);
                    
                    points.push({ x, y, z });
                }
                
                // 線分を作成
                for (let i = 0; i < points.length - 1; i++) {
                    const lineElement = document.createElement('div');
                    lineElement.className = 'grid-line grid-line-dec';
                    lineElement.style.left = '50%';
                    lineElement.style.top = '50%';
                    
                    starField.appendChild(lineElement);
                    
                    gridLines.push({
                        element: lineElement,
                        startPoint: points[i],
                        endPoint: points[i + 1],
                        type: 'dec'
                    });
                }
                
                // 赤緯ラベルを追加
                if (dec % 30 === 0) { // 30度ごとにラベル
                    const labelElement = document.createElement('div');
                    labelElement.className = 'grid-label';
                    labelElement.textContent = `${dec > 0 ? '+' : ''}${dec}°`;
                    
                    // ラベルを東(RA=6h)の位置に配置
                    const phi = (90 - dec) * Math.PI / 180;
                    const theta = (6 * 15) * Math.PI / 180; // RA=6h は 90度
                    
                    const x = starFieldRadius * Math.sin(phi) * Math.cos(theta);
                    const y = starFieldRadius * Math.sin(phi) * Math.sin(theta);
                    const z = starFieldRadius * Math.cos(phi);
                    
                    starField.appendChild(labelElement);
                    
                    gridLines.push({
                        element: labelElement,
                        x: x,
                        y: y,
                        z: z,
                        type: 'label'
                    });
                }
            }
            
            // 特別に天の赤道（赤緯0度）を強調表示
            const equatorPoints = [];
            for (let ra = 0; ra <= 360; ra += 10) {
                const phi = 90 * Math.PI / 180; // 赤緯0度
                const theta = ra * Math.PI / 180;
                
                const x = starFieldRadius * Math.sin(phi) * Math.cos(theta);
                const y = starFieldRadius * Math.sin(phi) * Math.sin(theta);
                const z = starFieldRadius * Math.cos(phi);
                
                equatorPoints.push({ x, y, z });
            }
            
            // 天の赤道線を作成
            for (let i = 0; i < equatorPoints.length - 1; i++) {
                const lineElement = document.createElement('div');
                lineElement.className = 'grid-line grid-line-dec';
                lineElement.style.left = '50%';
                lineElement.style.top = '50%';
                lineElement.style.borderLeft = '2px solid rgba(255, 200, 100, 0.6)';
                
                starField.appendChild(lineElement);
                
                gridLines.push({
                    element: lineElement,
                    startPoint: equatorPoints[i],
                    endPoint: equatorPoints[i + 1],
                    type: 'equator'
                });
            }
            
            // 赤道ラベルを追加
            const equatorLabelElement = document.createElement('div');
            equatorLabelElement.className = 'grid-label';
            equatorLabelElement.textContent = '赤道';
            equatorLabelElement.style.color = 'rgba(255, 200, 100, 0.8)';
            
            // ラベルを東(RA=6h)の位置に配置
            const eqPhi = 90 * Math.PI / 180;
            const eqTheta = (6 * 15) * Math.PI / 180; // RA=6h
            
            const eqX = starFieldRadius * Math.sin(eqPhi) * Math.cos(eqTheta);
            const eqY = starFieldRadius * Math.sin(eqPhi) * Math.sin(eqTheta);
            const eqZ = starFieldRadius * Math.cos(eqPhi);
            
            starField.appendChild(equatorLabelElement);
            
            gridLines.push({
                element: equatorLabelElement,
                x: eqX,
                y: eqY,
                z: eqZ,
                type: 'label'
            });
            
            console.log(`天球グリッドを生成しました: ${gridLines.length}個の要素`);
        }
        
        // グリッド表示切替機能
        function toggleGrid() {
            showGrid = !showGrid;
            
            if (showGrid) {
                document.getElementById('toggleGridBtn').textContent = 'グリッドOFF';
                generateCelestialGrid();
                showMessage("天球グリッドを表示しています", 1000);
            } else {
                document.getElementById('toggleGridBtn').textContent = 'グリッドON';
                // グリッド要素を非表示
                gridLines.forEach(line => {
                    if (line.element) {
                        line.element.style.display = 'none';
                    }
                });
                showMessage("天球グリッドを非表示にしました", 1000);
            }
        }
        
        // 視点の更新（デバイスの方向に応じて星空を動かす）
        function updateView() {
            if (!isRunning) return;
            
            try {
                // 現在の方向（センサーまたは手動）
                let viewAzimuth, viewAltitude;
                
                if (useSensors && !orientationLocked) {
                    // センサーからの値を使用
                    viewAzimuth = alpha;
                    viewAltitude = beta;
                } else {
                    // 手動設定値を使用
                    viewAzimuth = manualAzimuth;
                    viewAltitude = manualAltitude;
                }
                
                // アルファ（方位角）をラジアンに変換
                const alphaRad = viewAzimuth * Math.PI / 180;
                // ベータ（仰角）をラジアンに変換
                const betaRad = viewAltitude * Math.PI / 180;
                // ガンマ（回転）をラジアンに変換
                const gammaRad = gamma * Math.PI / 180;
                
                // 回転行列を作成（オイラー角からの変換）
                const sinAlpha = Math.sin(alphaRad);
                const cosAlpha = Math.cos(alphaRad);
                const sinBeta = Math.sin(betaRad);
                const cosBeta = Math.cos(betaRad);
                const sinGamma = Math.sin(gammaRad);
                const cosGamma = Math.cos(gammaRad);
                
                // 各星の位置を更新
                stars.forEach(star => {
                    // 視点からの相対位置を計算
                    const viewX = -star.x;
                    const viewY = -star.y;
                    const viewZ = -star.z;
                    
                    // デバイスの向きに基づいて回転
                    // 方位角（アルファ）による回転（Y軸周り）
                    const rotX1 = viewX * cosAlpha - viewZ * sinAlpha;
                    const rotY1 = viewY;
                    const rotZ1 = viewX * sinAlpha + viewZ * cosAlpha;
                    
                    // 仰角（ベータ）による回転（X軸周り）
                    const rotX2 = rotX1;
                    const rotY2 = rotY1 * cosBeta - rotZ1 * sinBeta;
                    const rotZ2 = rotY1 * sinBeta + rotZ1 * cosBeta;
                    
                    // 回転（ガンマ）による回転（Z軸周り）
                    const rotX3 = rotX2 * cosGamma - rotY2 * sinGamma;
                    const rotY3 = rotX2 * sinGamma + rotY2 * cosGamma;
                    const rotZ3 = rotZ2;
                    
                    // パースペクティブ投影（Z座標が大きいほど小さく表示）
                    const perspective = 1000; // パースペクティブの強さ
                    const scale = perspective / (perspective + rotZ3);
                    
                    // スクリーン上の座標を計算
                    const screenX = rotX3 * scale + window.innerWidth / 2;
                    const screenY = rotY3 * scale + window.innerHeight / 2;
                    
                    // 星の要素を移動（transformを使用して高速化）
                    star.element.style.transform = `translate(${screenX}px, ${screenY}px)`;
                    
                    // 星の明るさと大きさを距離に応じて調整
                    const distance = Math.sqrt(rotX3*rotX3 + rotY3*rotY3 + rotZ3*rotZ3);
                    const distanceScale = Math.min(1, starFieldRadius / distance);
                    
                    // スケールが小さすぎる場合は星を非表示にする
                    if (scale < 0.1 || rotZ3 > 0) {
                        star.element.style.display = 'none';
                    } else {
                        star.element.style.display = 'block';
                        star.element.style.opacity = star.brightness * scale;
                        star.element.style.width = star.size * scale + 'px';
                        star.element.style.height = star.size * scale + 'px';
                    }
                });
                
                // 星座ラベルの位置も同様に更新
                constellations.forEach(constellation => {
                    // 視点からの相対位置を計算
                    const viewX = -constellation.x;
                    const viewY = -constellation.y;
                    const viewZ = -constellation.z;
                    
                    // デバイスの向きに基づいて回転
                    // 方位角（アルファ）による回転（Y軸周り）
                    const rotX1 = viewX * cosAlpha - viewZ * sinAlpha;
                    const rotY1 = viewY;
                    const rotZ1 = viewX * sinAlpha + viewZ * cosAlpha;
                    
                    // 仰角（ベータ）による回転（X軸周り）
                    const rotX2 = rotX1;
                    const rotY2 = rotY1 * cosBeta - rotZ1 * sinBeta;
                    const rotZ2 = rotY1 * sinBeta + rotZ1 * cosBeta;
                    
                    // 回転（ガンマ）による回転（Z軸周り）
                    const rotX3 = rotX2 * cosGamma - rotY2 * sinGamma;
                    const rotY3 = rotX2 * sinGamma + rotY2 * cosGamma;
                    const rotZ3 = rotZ2;
                    
                    // パースペクティブ投影
                    const perspective = 1000;
                    const scale = perspective / (perspective + rotZ3);
                    
                    // スクリーン上の座標を計算
                    const screenX = rotX3 * scale + window.innerWidth / 2;
                    const screenY = rotY3 * scale + window.innerHeight / 2;
                    
                    // 星座ラベルを移動
                    constellation.element.style.transform = `translate(${screenX}px, ${screenY}px)`;
                    
                    // 視界の外または後ろにある星座は非表示に
                    if (scale < 0.1 || rotZ3 > 0 || 
                        screenX < 0 || screenX > window.innerWidth || 
                        screenY < 0 || screenY > window.innerHeight) {
                        constellation.element.style.display = 'none';
                    } else {
                        constellation.element.style.display = 'block';
                        constellation.element.style.opacity = scale * 0.7;
                    }
                });
                
                // グリッド線を更新
                updateGridLines(alphaRad, betaRad, gammaRad);
                
                // 方向表示を更新
                updateDirection(viewAzimuth);
                
            } catch (error) {
                console.warn('視点更新エラー:', error);
            }
        }
        
        // グリッド線の更新処理
        function updateGridLines(alphaRad, betaRad, gammaRad) {
            // 回転行列の要素
            const sinAlpha = Math.sin(alphaRad);
            const cosAlpha = Math.cos(alphaRad);
            const sinBeta = Math.sin(betaRad);
            const cosBeta = Math.cos(betaRad);
            const sinGamma = Math.sin(gammaRad);
            const cosGamma = Math.cos(gammaRad);
            
            // グリッドが非表示の場合は更新しない
            if (!showGrid) return;
            
            // 各グリッド要素を更新
            gridLines.forEach(line => {
                if (line.type === 'label') {
                    // ラベル要素の場合
                    const viewX = -line.x;
                    const viewY = -line.y;
                    const viewZ = -line.z;
                    
                    // 方位角（アルファ）による回転
                    const rotX1 = viewX * cosAlpha - viewZ * sinAlpha;
                    const rotY1 = viewY;
                    const rotZ1 = viewX * sinAlpha + viewZ * cosAlpha;
                    
                    // 仰角（ベータ）による回転
                    const rotX2 = rotX1;
                    const rotY2 = rotY1 * cosBeta - rotZ1 * sinBeta;
                    const rotZ2 = rotY1 * sinBeta + rotZ1 * cosBeta;
                    
                    // 回転（ガンマ）による回転
                    const rotX3 = rotX2 * cosGamma - rotY2 * sinGamma;
                    const rotY3 = rotX2 * sinGamma + rotY2 * cosGamma;
                    const rotZ3 = rotZ2;
                    
                    // パースペクティブ投影
                    const perspective = 1000;
                    const scale = perspective / (perspective + rotZ3);
                    
                    // スクリーン上の座標
                    const screenX = rotX3 * scale + window.innerWidth / 2;
                    const screenY = rotY3 * scale + window.innerHeight / 2;
                    
                    // 要素の位置を更新
                    line.element.style.transform = `translate(${screenX}px, ${screenY}px)`;
                    
                    // 視界の外か後ろにある場合は非表示
                    if (scale < 0.1 || rotZ3 > 0 || 
                        screenX < 0 || screenX > window.innerWidth || 
                        screenY < 0 || screenY > window.innerHeight) {
                        line.element.style.display = 'none';
                    } else {
                        line.element.style.display = 'block';
                        line.element.style.opacity = scale * 0.7;
                    }
                } else {
                    // グリッド線の場合
                    const startPoint = line.startPoint;
                    const endPoint = line.endPoint;
                    
                    // 始点
                    let viewX1 = -startPoint.x;
                    let viewY1 = -startPoint.y;
                    let viewZ1 = -startPoint.z;
                    
                    // 方位角（アルファ）による回転
                    let rotX1a = viewX1 * cosAlpha - viewZ1 * sinAlpha;
                    let rotY1a = viewY1;
                    let rotZ1a = viewX1 * sinAlpha + viewZ1 * cosAlpha;
                    
                    // 仰角（ベータ）による回転
                    let rotX1b = rotX1a;
                    let rotY1b = rotY1a * cosBeta - rotZ1a * sinBeta;
                    let rotZ1b = rotY1a * sinBeta + rotZ1a * cosBeta;
                    
                    // 回転（ガンマ）による回転
                    let rotX1c = rotX1b * cosGamma - rotY1b * sinGamma;
                    let rotY1c = rotX1b * sinGamma + rotY1b * cosGamma;
                    let rotZ1c = rotZ1b;
                    
                    // 終点
                    let viewX2 = -endPoint.x;
                    let viewY2 = -endPoint.y;
                    let viewZ2 = -endPoint.z;
                    
                    // 方位角（アルファ）による回転
                    let rotX2a = viewX2 * cosAlpha - viewZ2 * sinAlpha;
                    let rotY2a = viewY2;
                    let rotZ2a = viewX2 * sinAlpha + viewZ2 * cosAlpha;
                    
                    // 仰角（ベータ）による回転
                    let rotX2b = rotX2a;
                    let rotY2b = rotY2a * cosBeta - rotZ2a * sinBeta;
                    let rotZ2b = rotY2a * sinBeta + rotZ2a * cosBeta;
                    
                    // 回転（ガンマ）による回転
                    let rotX2c = rotX2b * cosGamma - rotY2b * sinGamma;
                    let rotY2c = rotX2b * sinGamma + rotY2b * cosGamma;
                    let rotZ2c = rotZ2b;
                    
                    // パースペクティブ投影
                    const perspective = 1000;
                    let scale1 = perspective / (perspective + rotZ1c);
                    let scale2 = perspective / (perspective + rotZ2c);
                    
                    // スクリーン上の座標
                    let screenX1 = rotX1c * scale1 + window.innerWidth / 2;
                    let screenY1 = rotY1c * scale1 + window.innerHeight / 2;
                    let screenX2 = rotX2c * scale2 + window.innerWidth / 2;
                    let screenY2 = rotY2c * scale2 + window.innerHeight / 2;
                    
                    // 線の両端が視界の外か後ろにある場合は非表示
                    if ((scale1 < 0.1 && scale2 < 0.1) || 
                        (rotZ1c > 0 && rotZ2c > 0) ||
                        (screenX1 < 0 && screenX2 < 0) || 
                        (screenX1 > window.innerWidth && screenX2 > window.innerWidth) || 
                        (screenY1 < 0 && screenY2 < 0) || 
                        (screenY1 > window.innerHeight && screenY2 > window.innerHeight)) {
                        line.element.style.display = 'none';
                        return;
                    }
                    
                    // 線の位置と長さ、角度を計算
                    const dx = screenX2 - screenX1;
                    const dy = screenY2 - screenY1;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    // 表示位置を始点に設定
                    line.element.style.transform = `translate(${screenX1}px, ${screenY1}px) rotate(${angle}deg)`;
                    line.element.style.width = `${length}px`;
                    line.element.style.height = '1px';
                    
                    // 視界内に表示
                    line.element.style.display = 'block';
                    
                    // 距離に応じて透明度を調整
                    const avgScale = (scale1 + scale2) / 2;
                    const opacity = line.type === 'equator' ? avgScale * 0.7 : avgScale * 0.4;
                    line.element.style.opacity = opacity.toString();
                }
            });
        }
        
        // 画面の向き変更イベント処理
        function handleOrientationChange() {
            if (orientationLocked) return; // 方向がロックされている場合は何もしない
            
            updateHorizonPosition();
            updateBlackholeMarkers();
        }
        
        // 地平線の位置を更新
        function updateHorizonPosition() {
            const horizon = document.getElementById('horizon');
            const horizonLabel = horizon.querySelector('.horizon-label');
            
            // ベータとガンマの値に基づいて地平線の位置を決定
            if (Math.abs(gamma) > Math.abs(beta)) {
                // 横向きの場合
                if (gamma > 0) {
                    // 右側が下
                    horizonPosition = 'right';
                    horizon.style.width = '20%';
                    horizon.style.height = '100%';
                    horizon.style.top = '0';
                    horizon.style.left = 'auto';
                    horizon.style.right = '0';
                    horizon.style.bottom = 'auto';
                    horizon.style.background = 'linear-gradient(270deg, rgba(0,40,0,0.8) 0%, rgba(0,0,0,0) 100%)';
                    
                    // 地平線ラベルを調整
                    horizonLabel.style.bottom = '50%';
                    horizonLabel.style.transform = 'rotate(90deg) translateY(-10px)';
                    horizonLabel.style.transformOrigin = 'right center';
                } else {
                    // 左側が下
                    horizonPosition = 'left';
                    horizon.style.width = '20%';
                    horizon.style.height = '100%';
                    horizon.style.top = '0';
                    horizon.style.left = '0';
                    horizon.style.right = 'auto';
                    horizon.style.bottom = 'auto';
                    horizon.style.background = 'linear-gradient(90deg, rgba(0,40,0,0.8) 0%, rgba(0,0,0,0) 100%)';
                    
                    // 地平線ラベルを調整
                    horizonLabel.style.bottom = '50%';
                    horizonLabel.style.transform = 'rotate(-90deg) translateY(-10px)';
                    horizonLabel.style.transformOrigin = 'left center';
                }
            } else {
                // 縦向きの場合
                if (beta > 0) {
                    // 下側が下
                    horizonPosition = 'bottom';
                    horizon.style.width = '100%';
                    horizon.style.height = '20%';
                    horizon.style.top = 'auto';
                    horizon.style.left = '0';
                    horizon.style.right = 'auto';
                    horizon.style.bottom = '0';
                    horizon.style.background = 'linear-gradient(0deg, rgba(0,40,0,0.8) 0%, rgba(0,0,0,0) 100%)';
                    
                    // 地平線ラベルを調整
                    horizonLabel.style.bottom = '5px';
                    horizonLabel.style.transform = 'none';
                } else {
                    // 上側が下
                    horizonPosition = 'top';
                    horizon.style.width = '100%';
                    horizon.style.height = '20%';
                    horizon.style.top = '0';
                    horizon.style.left = '0';
                    horizon.style.right = 'auto';
                    horizon.style.bottom = 'auto';
                    horizon.style.background = 'linear-gradient(180deg, rgba(0,40,0,0.8) 0%, rgba(0,0,0,0) 100%)';
                    
                    // 地平線ラベルを調整
                    horizonLabel.style.bottom = 'auto';
                    horizonLabel.style.top = '5px';
                    horizonLabel.style.transform = 'none';
                }
            }
        }
        
        // リサイズ処理
        function handleResize() {
            if (canvas) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            // 3D星空や星座の位置を更新
            updateView();
            
            if (isRunning) {
                updateBlackholeMarkers();
            }
        }
        
        // 方角表示の更新
        function updateDirection(heading) {
            const directions = ["北", "北東", "東", "南東", "南", "南西", "西", "北西"];
            const index = Math.round(heading / 45) % 8;
            document.getElementById('viewDirection').textContent = `${directions[index]} (${heading.toFixed(1)}°)`;
        }
        
        // シンプルなブラックホール表示（緊急時用）
        function createSimpleBlackholeMarkers() {
            // 画面中央にブラックホールを配置
            blackholes.forEach((blackhole, index) => {
                const x = window.innerWidth / 2 + (index - 2) * 60;
                const y = window.innerHeight / 2;
                
                createBlackholeMarker(blackhole, x, y);
            });
            
            // 視野内のブラックホール数を更新
            document.getElementById('visibleCount').textContent = blackholes.length;
        }
        
        // ブラックホールマーカーを更新
        function updateBlackholeMarkers() {
            // 既存のマーカーを削除
            markers.forEach(marker => {
                if (marker.element && marker.element.parentNode) {
                    marker.element.parentNode.removeChild(marker.element);
                }
            });
            markers = [];
            
            // 新しいマーカーを作成
            createBlackholeMarkers();
        }
        
        // 通常のブラックホールマーカー作成
        function createBlackholeMarkers() {
            // 赤経・赤緯からスクリーン座標に変換してブラックホールを配置
            blackholes.forEach((blackhole, index) => {
                // 赤経・赤緯を角度に変換
                const ra = blackhole.ra; // 度単位
                const dec = blackhole.dec; // 度単位
                
                // 赤経・赤緯を3D座標に変換
                const phi = (90 - dec) * Math.PI / 180; // 天頂角（北極が0）
                const theta = ra * Math.PI / 180; // 方位角
                
                const x = starFieldRadius * Math.sin(phi) * Math.cos(theta);
                const y = starFieldRadius * Math.sin(phi) * Math.sin(theta);
                const z = starFieldRadius * Math.cos(phi);
                
                // 現在の視点に基づいて回転と投影
                const alphaRad = (useSensors && !orientationLocked ? alpha : manualAzimuth) * Math.PI / 180;
                const betaRad = (useSensors && !orientationLocked ? beta : manualAltitude) * Math.PI / 180;
                const gammaRad = gamma * Math.PI / 180;
                
                // 回転行列の計算
                const sinAlpha = Math.sin(alphaRad);
                const cosAlpha = Math.cos(alphaRad);
                const sinBeta = Math.sin(betaRad);
                const cosBeta = Math.cos(betaRad);
                const sinGamma = Math.sin(gammaRad);
                const cosGamma = Math.cos(gammaRad);
                
                // 視点からの相対位置
                const viewX = -x;
                const viewY = -y;
                const viewZ = -z;
                
                // 方位角（アルファ）による回転
                const rotX1 = viewX * cosAlpha - viewZ * sinAlpha;
                const rotY1 = viewY;
                const rotZ1 = viewX * sinAlpha + viewZ * cosAlpha;
                
                // 仰角（ベータ）による回転
                const rotX2 = rotX1;
                const rotY2 = rotY1 * cosBeta - rotZ1 * sinBeta;
                const rotZ2 = rotY1 * sinBeta + rotZ1 * cosBeta;
                
                // 回転（ガンマ）による回転
                const rotX3 = rotX2 * cosGamma - rotY2 * sinGamma;
                const rotY3 = rotX2 * sinGamma + rotY2 * cosGamma;
                const rotZ3 = rotZ2;
                
                // パースペクティブ投影
                const perspective = 1000;
                const scale = perspective / (perspective + rotZ3);
                
                // スクリーン上の座標
                const screenX = rotX3 * scale + window.innerWidth / 2;
                const screenY = rotY3 * scale + window.innerHeight / 2;
                
                // 視界内にある場合のみマーカーを作成
                if (scale > 0.1 && rotZ3 < 0 && 
                    screenX >= 0 && screenX <= window.innerWidth && 
                    screenY >= 0 && screenY <= window.innerHeight) {
                    
                    // 地平線に対する位置を判定
                    let isAboveHorizon = true;
                    if (horizonPosition === 'bottom' && screenY > window.innerHeight * 0.8) {
                        isAboveHorizon = false;
                    } else if (horizonPosition === 'top' && screenY < window.innerHeight * 0.2) {
                        isAboveHorizon = false;
                    } else if (horizonPosition === 'left' && screenX < window.innerWidth * 0.2) {
                        isAboveHorizon = false;
                    } else if (horizonPosition === 'right' && screenX > window.innerWidth * 0.8) {
                        isAboveHorizon = false;
                    }
                    
                    createBlackholeMarker(blackhole, screenX, screenY, isAboveHorizon, scale);
                }
            });
            
            // 視野内のブラックホール数を更新
            document.getElementById('visibleCount').textContent = markers.length;
        }
        
        // ブラックホールマーカーを作成
        function createBlackholeMarker(blackhole, x, y, isAboveHorizon, scale) {
            const marker = document.createElement('div');
            marker.className = 'blackhole-marker';
            marker.style.left = `${x}px`;
            marker.style.top = `${y}px`;
            
            // 地平線以下の場合は薄く表示
            if (!isAboveHorizon) {
                marker.style.opacity = '0.5';
                marker.style.border = '1px solid rgba(255, 0, 0, 0.8)';
                marker.style.backgroundColor = 'rgba(100, 0, 0, 0.5)';
            }
            
            // スケールに応じてサイズを調整
            if (scale) {
                const size = 30 * Math.min(1, scale * 1.5);
                marker.style.width = `${size}px`;
                marker.style.height = `${size}px`;
            }
            
            // クリックイベント
            marker.addEventListener('click', function() {
                showBlackholeInfo(blackhole, isAboveHorizon);
            });
            
            document.getElementById('container').appendChild(marker);
            
            // マーカーを記録
            markers.push({
                element: marker,
                blackhole: blackhole,
                isAboveHorizon: isAboveHorizon
            });
        }
        
        // ブラックホール情報を表示
        function showBlackholeInfo(blackhole, isAboveHorizon) {
            const infoPanel = document.getElementById('objectInfo');
            
            document.getElementById('objectName').textContent = blackhole.name;
            document.getElementById('objectDistance').textContent = `距離: ${blackhole.distance}`;
            document.getElementById('objectMass').textContent = `質量: ${blackhole.mass}`;
            document.getElementById('objectDescription').textContent = blackhole.description;
            
            // 地平線以下の場合は注意を表示
            if (!isAboveHorizon) {
                const description = document.getElementById('objectDescription');
                description.textContent += "\n（注意：この天体は現在地平線より下にあります）";
            }
            
            infoPanel.style.display = 'block';
            
            // 5秒後に非表示
            setTimeout(function() {
                infoPanel.style.display = 'none';
            }, 5000);
        }
        
        // マニュアル方向設定（センサーが使えない場合）
        function useFallbackOrientation() {
            useSensors = false;
            document.getElementById('toggleSensorsBtn').textContent = 'センサーON';
            
            // 固定方向に設定
            alpha = 0; // 北向き
            beta = 45; // 45度上向き
            gamma = 0;
            manualAzimuth = 0;
            manualAltitude = 45;
            updateDirection(0);
        }
        
        // デバイスの向きハンドラ
        function handleOrientation(event) {
            // センサーが無効化されている場合は何もしない
            if (!useSensors) return;
            
            try {
                // iOS/Androidの違いを吸収
                alpha = event.alpha || 0; // z軸周りの回転 (0-360)
                beta = event.beta || 0;   // x軸周りの回転 (-180-180)
                gamma = event.gamma || 0; // y軸周りの回転 (-90-90)
                
                // センサー値の表示を更新
                document.getElementById('alphaValue').textContent = alpha.toFixed(1);
                document.getElementById('betaValue').textContent = beta.toFixed(1);
                document.getElementById('gammaValue').textContent = gamma.toFixed(1);
                
                // 方向がロックされていない場合は地平線位置を更新
                if (!orientationLocked) {
                    updateHorizonPosition();
                }
            } catch (error) {
                console.warn('向き検出エラー:', error);
                // エラー時はデフォルト値を使用
                useSensors = false;
                document.getElementById('toggleSensorsBtn').textContent = 'センサーON';
            }
        }
        
        // タッチ/マウス操作のセットアップ
        function setupTouchControls() {
            const container = document.getElementById('container');
            
            // タッチイベント
            container.addEventListener('touchstart', handleTouchStart, false);
            container.addEventListener('touchmove', handleTouchMove, false);
            container.addEventListener('touchend', handleTouchEnd, false);
            
            // マウスイベント（PC用）
            container.addEventListener('mousedown', handleMouseDown, false);
            container.addEventListener('mousemove', handleMouseMove, false);
            container.addEventListener('mouseup', handleMouseUp, false);
        }
        
        // タッチ開始
        function handleTouchStart(event) {
            event.preventDefault();
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchLastX = touchStartX;
            touchLastY = touchStartY;
            isDragging = true;
            
            // ドラッグ開始時に方向をロック
            orientationLocked = true;
            
            // センサーを無効化（手動操作中）
            if (isDragging) {
                useSensors = false;
                document.getElementById('toggleSensorsBtn').textContent = 'センサーON';
            }
        }
        
        // タッチ移動
        function handleTouchMove(event) {
            if (!isDragging) return;
            event.preventDefault();
            
            const touch = event.touches[0];
            const deltaX = touch.clientX - touchLastX;
            const deltaY = touch.clientY - touchLastY;
            
            // 方位角と高度を更新（横方向の動きで方位角、縦方向の動きで高度を変更）
            manualAzimuth = (manualAzimuth - deltaX * 0.5) % 360;
            if (manualAzimuth < 0) manualAzimuth += 360;
            
            manualAltitude += deltaY * 0.5;
            // 高度の制限（-10度から90度の範囲に制限）
            manualAltitude = Math.max(-10, Math.min(90, manualAltitude));
            
            touchLastX = touch.clientX;
            touchLastY = touch.clientY;
        }
        
        // タッチ終了
        function handleTouchEnd(event) {
            isDragging = false;
        }
        
        // マウスダウン
        function handleMouseDown(event) {
            event.preventDefault();
            touchStartX = event.clientX;
            touchStartY = event.clientY;
            touchLastX = touchStartX;
            touchLastY = touchStartY;
            isDragging = true;
            
            // ドラッグ開始時に方向をロック
            orientationLocked = true;
            
            // センサーを無効化（手動操作中）
            if (isDragging) {
                useSensors = false;
                document.getElementById('toggleSensorsBtn').textContent = 'センサーON';
            }
        }
        
        // マウス移動
        function handleMouseMove(event) {
            if (!isDragging) return;
            event.preventDefault();
            
            const deltaX = event.clientX - touchLastX;
            const deltaY = event.clientY - touchLastY;
            
            // 方位角と高度を更新
            manualAzimuth = (manualAzimuth - deltaX * 0.5) % 360;
            if (manualAzimuth < 0) manualAzimuth += 360;
            
            manualAltitude += deltaY * 0.5;
            // 高度の制限（-10度から90度の範囲に制限）
            manualAltitude = Math.max(-10, Math.min(90, manualAltitude));
            
            touchLastX = event.clientX;
            touchLastY = event.clientY;
        }
        
        // マウスアップ
        function handleMouseUp(event) {
            isDragging = false;
        }
        
        // 視点リセット
        function resetView() {
            // 方向ロックを解除
            orientationLocked = false;
            
            // センサーを有効化
            useSensors = true;
            document.getElementById('toggleSensorsBtn').textContent = 'センサーOFF';
            
            // 現在のセンサー値で地平線位置を更新
            updateHorizonPosition();
            
            // マーカーを更新
            updateBlackholeMarkers();
            
            showMessage("視点をリセットしました。スマホの方向に連動します。", 2000);
        }
        
        // センサー切替
        function toggleSensors() {
            useSensors = !useSensors;
            
            if (useSensors) {
                document.getElementById('toggleSensorsBtn').textContent = 'センサーOFF';
                orientationLocked = false; // ロック解除
                showMessage("センサーモードに切り替えました", 1000);
            } else {
                document.getElementById('toggleSensorsBtn').textContent = 'センサーON';
                orientationLocked = true; // ロック
                showMessage("手動操作モードに切り替えました", 1000);
            }
        }
    </script>
</body>
</html>
